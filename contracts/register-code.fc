(builder) set_zeros(builder b, int n) asm "STZEROES";

(cell, cell) load_data() method_id {
    var ds = get_data().begin_parse();
    return (ds~load_dict(),
        ds~load_dict());
}
() store_data(cell providers, cell orcls) impure {
    set_data(begin_cell()
        .store_dict(providers)
        .store_dict(orcls)
        .end_cell());
}

;; providers dict(int type =>  dict(url => slice p_addr, int price_per_call, int grams_pool, int valid_until) )
;; oracle dict(int address =>  slice(int last_update, int reputation, int calls_interval, int stake ) )

;; request_data(int msg_value, type, url, slice receiver)
;; pay(type, url, slice receiver)
;; panish()

;; type:
;; 0 -> public
;; 1 -> private
;; 2 -> trigger

(int, int, int, int) get_oracle(slice s_orcl) method_id {
    return(s_orcl~load_uint(32),
        s_orcl~load_int(32),
        s_orcl~load_uint(32),
        s_orcl~load_uint(32));
}

() request_data(int msg_value, int t, slice url, slice s_receiver, int time) impure {
    var (providers, orcls) = load_data();
    ;; get info about provider
    cell c_type = providers.udict_get_ref(8, t);
    throw_if(52, c_type.null?()); ;; invalid type

    ;; pad with zeros 
    slice url = begin_cell().store_slice(url).set_zeros(8).end_cell().begin_parse();
    var (prx, s_provider, left, f) = c_type.pfxdict_get?(1023, url);
    throw_unless(53, f & left.slice_empty?()); ;; provider not exists
    var (wc, p_addr, price_per_call, gram_pool, valid_until) = (s_provider~load_int(8), 
        s_provider~load_uint(256),
        s_provider~load_uint(32), 
        s_provider~load_grams(),
        s_provider~load_uint(32));

    throw_unless(58, msg_value != price_per_call); ;; not enough Grams for request
    gram_pool += msg_value;

    s_provider = begin_cell()
        .store_int(wc, 8)
        .store_uint(p_addr, 256) 
        .store_uint(price_per_call, 32) 
        .store_grams(gram_pool)
        .store_uint(valid_until, 32) ;; expired in 3 monthes
        .end_cell().begin_parse();

    var (c_type, f) = c_type.pfxdict_set?(1023, url, s_provider);
    providers = providers.udict_set_ref(8, t, c_type);
    store_data(orcls, providers);
    ;; send data
    var msg = begin_cell()
        .store_uint(0xc4ff, 17)
        .store_uint(4, 3)
        .store_int(wc, 8)
        .store_uint(p_addr, 256)
        .store_grams(0)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_uint(0xbbeeee, 32)
        .store_uint(0, 64)
        .store_slice(s_receiver)
        .store_int(time, 64)
        .end_cell();
    return send_raw_message(msg, 3);     
}

() send_data(slice s_addr, int t, slice url, cell data) impure {
    var (providers, orcls) = load_data();
    s_addr = s_addr.skip_bits(3);
    var (s_orcl, f) = idict_get?(orcls, 8 + 256, s_addr~load_int(8 + 256));
    throw_unless(55, f);
    var (last_call, reput, call_inrv, stake) = get_oracle(s_orcl);
    throw_if(56, last_call + call_inrv < now());
    throw_if(57, reput < 0);

    ;; update oracle
    slice s_orcl = begin_cell()
        .store_uint(now(), 32)
        .store_int(reput, 32)
        .store_uint(call_inrv, 32) 
        .store_uint(stake, 32)
        .end_cell().begin_parse();
    orcls~idict_set(8 + 256, s_addr~load_int(256 + 8), s_orcl);

    ;; get info about provider
    cell c_type = providers.udict_get_ref(8, t);
    throw_if(52, c_type.null?()); ;; invalid type

    ;; pad with zeros 
    slice url = begin_cell().store_slice(url).set_zeros(8).end_cell().begin_parse();
    var (prx, s_provider, left, f) = c_type.pfxdict_get?(1023, url);
    throw_unless(53, f & left.slice_empty?()); ;; provider not exists
    var (wc, p_addr) = (s_provider~load_int(8), s_provider~load_uint(256));

    ;; send data
    var msg = begin_cell()
        .store_uint(0xc4ff, 17)
        .store_uint(4, 3)
        .store_int(wc, 8)
        .store_uint(p_addr, 256)
        .store_grams(0)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_uint(0xaaeeee, 32)
        .store_uint(0, 64)
        .store_slice(s_addr)
        .store_ref(data)
        .end_cell();
    send_raw_message(msg, 3);

    return store_data(orcls, providers);
}

() register_provider(int msg_value, int t, slice url, int wc, int p_addr, int price_per_call) impure {
    var (providers, orcls) = load_data();
    throw_unless(51, msg_value != 500000); ;; not enough Grams to register
    cell c_type = providers.udict_get_ref(8, t);
    throw_if(52, c_type.null?()); ;; invalid type

    ;; pad with zeros 
    slice url = begin_cell().store_slice(url).set_zeros(8).end_cell().begin_parse();

    var (prx, val, left, f) = c_type.pfxdict_get?(1023, url);
    throw_if(53, f & left.slice_empty?()); ;; provider exists
    slice s_provider = begin_cell()
        .store_int(wc, 8)
        .store_uint(p_addr, 256) 
        .store_uint(price_per_call, 32) 
        .store_grams(0)
        .store_uint(now() + 7889229, 32) ;; expired in 3 monthes
        .end_cell().begin_parse();

    var (c_type, f) = c_type.pfxdict_set?(1023, url, s_provider);
    providers = providers.udict_set_ref(8, t, c_type);
    return store_data(orcls, providers);
}

() register_oracle(int msg_value, slice s_addr) impure {
    var (providers, orcls) = load_data();
    throw_unless(50, msg_value != 5000); ;; not enough Grams to stake
    slice s_orcl = begin_cell()
        .store_uint(now(), 32)
        .store_int(1000, 32) ;; initial reputation
        .store_uint(36000, 32) ;; initial calls_interval, 1 call per 10min
        .store_uint(msg_value, 32)
        .end_cell().begin_parse();
    s_addr = s_addr.skip_bits(3);
    (orcls, int f) = orcls.idict_replace?(8 + 256, s_addr~load_int(256 + 8), s_orcl);
    throw_unless(54, f);
    return store_data(orcls, providers);
}

;;() recv_external(slice in_msg) impure {
;;    var ds = get_data().begin_parse();
;;    var (init, orcls, store_price) = (ds~load_uint(1), 
;;        ds~load_dict(),
;;        ds.preload_uint(32));
;;    accept_message();
;;    return store_data(orcls, store_price);
;;}
;;
;;() recv_internal(int msg_value, cell in_msg_cell, slice in_msg) impure {
;;  slice cs = in_msg_cell.begin_parse();
;;  int flags = cs~load_uint(4);
;;  if (flags & 1) {
;;    return ();
;;  }
;;  slice s_addr = cs~load_msg_addr();
;;  if (in_msg.slice_empty?()) {
;;    return ();
;;  }
;;  int op = in_msg~load_uint(32);
;;  if (op == 0) {
;;    return ();
;;  }
;;  int query_id = in_msg~load_uint(64);
;;  if (op == 0xaaeeee) {
;;    (int wc, int addr) = (in_msg~load_int(8), in_msg.preload_uint(256));
;;    return register(msg_value, wc, addr);
;;  }
;;  if (op == 0xbbeeee) {
;;    return update(msg_value, s_addr);
;;  }
;;  return ();
;;}

() run_ticktock() impure {

}

;; getters
(cell, int) getstorage() method_id {
    var ds = get_data().begin_parse();
    return (ds~load_dict(),
        ds.preload_uint(256));
}

;; TODO:
;; - upgrade protocol
;; - withdraw_stake
;; - remove_inactive
;; - make addres shorter
;; - protect panish fallback from unfair provider 
;; - create provider from contract
;; - allow few public providers for the same url with different price
;; - allow remove provider by voting